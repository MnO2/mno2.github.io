<!doctype html>
<html>
    <head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-140890995-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-140890995-1');
  </script>
  <meta charset="utf-8">
  <title>Paul Meng's Blog</title>
  <link rel="canonical" href="https://blog.paulme.ng" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="AhCspkSlkxfv5A28XyOOTijnA59_q-V8rJzKakb4CFA" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta property="og:title" content="Paul Meng's Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://blog.paulme.ng" />

  <link href="https://fonts.googleapis.com/css?family=EB+Garamond|Roboto&display=swap" rel="stylesheet"> 
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP|Noto+Sans+TC&display=optional" rel="stylesheet"> 
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css">
  <link rel="stylesheet" href="../stylesheets/customize-1622403341.css">
  <style>
    html, button, input, select, textarea,
    .pure-g [class *= "pure-u"] {
      font-family: 'Roboto', 'Noto Sans TC', 'Noto Sans JP', sans-serif;
    }

    .post-title {
      font-family: 'EB Garamond', 'Noto Sans TC', 'Noto Sans JP', serif;
    }
  </style>
</head>

    <body>
        <div class="pure-menu pure-menu-horizontal">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><a href="../about" class="pure-menu-link">About</a></li>
                <li class="pure-menu-item"><a href="../archive.html" class="pure-menu-link">Archive</a></li>
                <li class="pure-menu-item"><a href="../rss/feed.xml" class="pure-menu-link">Subscribe</a></li>
            </ul>
        </div>
        <main class="content" role="main">
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2012-04-04-%E4%B8%AD%E6%9D%B1%E7%8F%BE%E5%A0%B4%E8%88%87%E6%8B%89%E4%B8%81%E7%BE%8E%E6%B4%B2%E7%9C%9F%E7%9B%B8%E4%B9%8B%E8%B7%AF.html">中東現場與拉丁美洲真相之路</a></h1>
    <div class="post-meta"><time datetime="2012-04-04 17:30">2012-04-04 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p><img src="../images/legacy/0*lgdZshc6cizOkPY7.jpg" /></p>
<p>這是一篇欠了很久的讀書心得。 拖了很久是因為每每讀完這類開拓視野、發人深省的書便在下筆與反覆咀嚼兩端擺盪。 想下筆是因為覺得這些書可以讓閱讀的人更進一歩接近事情的本質，想透過推薦找出願意品嘗知識所造成的孤獨感的人。就算小眾至少世上是有人可以分享的。 猶豫著反思又是怕說自己所學甚淺，未累積足夠智識可以找出脈絡獨立判斷閱讀的資料。 閱讀過後的衝擊、激動或許是一種危險、缺乏冷靜的判斷。</p>
<p>特別是像這兩本著名的香港獨立記者張翠容所寫的中東現場與 拉丁美洲真相之路， 每每讀到這類各國現況的所聞紀實、關鍵人物採訪好似在提醒自己所學有多麼淺薄。 了解政治、人民生活的現況往往需要歷史脈絡的追尋、政治左右派之爭、經濟史各個流派強堆的學說、彼此串連糾纏在一起才能窺得真相的某一面。 讀翠容的書的好處是她用淺顯的文字，在行文中也融進了消化上數知識後的分析見解。 可以讓你自己需要做的功課少了許多。 但這樣的缺點就是會讓你的讀書心得寫不下手， 因為覺得怎麼寫都覺得自己寫的心得沒什麼附加價值，浪費了看這篇心得的人的時間。 還不如直接附上連結，指著說「趕快去看本書吧。」</p>
<p>這邊只分享一個特別有印象的事: 眾所皆知猶太人於二戰被屠殺，是被迫害者。 二戰後以色列立國，不出幾年過去的迫害者變成了擴張主義的征服者。 撇開巴勒斯坦土地不說， 1982年在以色列的介入下，黎巴嫩的巴人難民營被血洗、屠殺。 成了難民逃到別國還要被趕盡殺絕，這是什麼道理。 同樣距今不到十年，2002另一個名為Jenin難民營亦遭到以色列屠殺。 我知道這件事的時候完全可以體會自殺炸彈這種攻擊是怎麼來的， 當你被逼到絕境，生命毫無出路時，死亡並不是一件可怕的事， 可以順便把你恨透的敵人一起拖下水可說是絕佳划算。 歷史或許就在人性中不斷地糾纏發展， 過去的被害者也不一定會記住教訓，而不要讓事情再發生。</p>
<p>最後，儘管在現今Twitter、Facebook等短文平台被號稱為新媒體的現在， 還是來列一些早些年所謂的獨立媒體或是公民媒體平台好了。 雖然以我的學識也沒有辦法嚴格區分這些的定義有什麼不同。 但至少在這個世界受到主流美國媒體強烈主導下，提供些不同有組織性的管道可以了解世界。 相信其中也是有不少像翠容一樣智識的人在付出。</p>
<p>最有名的是不外乎就是Global Voices，也是流量最大的。 他是Ethan Zuckerman跟Rebecca MacKinnon在2004年在哈佛法學院的贊助下成立的。 也是目前看到的平台中最容易透過多國語言翻譯來閱讀的。</p>
<p>另外就是在1999年透過反全球化活動、希望聚集眾人力量的前提下而重力的Independent Media Center。 算是串連世界各地獨立媒體的平台。只要符合一些條件，確認你可以自己運作一個獨立媒體組織就可以申請加入串連。</p>
<p>至於一些地區性的著名獨立媒體羅列如下</p>
<ul>
<li>加拿大的Now Public</li>
<li>美國的Democracy Now</li>
<li>韓國的Oh My News</li>
<li>香港的獨立媒體</li>
<li>台灣的苦勞網以及Peopo</li>
</ul>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2012-03-17-haskell-blaze-builder.html">Haskell Library Survey: Blaze-Builder</a></h1>
    <div class="post-meta"><time datetime="2012-03-17 17:30">2012-03-17 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p>Haskell is notorious for plethoric libraries on Hackage. For a beginner, it’s easy to lose in the forest of Hackage. With the establishment of Haskell Platform and the advice from experts ( link1, link2 ). the situation is getting better. But for a community, more tutorials would be more plausible. Therefore I decide to write down my library survey.</p>
<h3 id="what-is-this-library-for">What is this library for?</h3>
<p>If you remembered it well in Learn you a Haskell for Great Good, it mentions that the List append operation (++) takes linear time. It’s implementation in Haskell 98 Report looks like this:</p>
<pre><code>infixr 5  ++
(++) :: [a] -&gt; [a] -&gt; [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)</code></pre>
<p>It’s obvious you have to traverse through all of the elements in the first list to get the operation done, hence linear time. And fortunately, ++ is right associative, which means when you are writing snippets like this, assuming as, bs, cs are all lists.</p>
<p>It essentially means</p>
<pre><code>(as ++ (bs ++ cs))</code></pre>
<p>Based on the previous reasoning, it won’t cost us too much, merely the length of as plus the length of bs.</p>
<p>But there IS some common cases that gets us in trouble. Let’s take a look at this example from here:</p>
<p>appendToContent str page = page {pageContent = newContent} where newContent = (pageContent page) ++ str It is a naiive implementation usually occurs in Logger or the streaming output of a HTTP server. The problem of this pattern is it forces the concatenation to be left associative. Using the previous as ++ bs ++ cs as our example, it will become:</p>
<pre><code>((as ++ bs) ++ cs)</code></pre>
<p>It is unacceptable because the left associative ++ costs us quadratic time in the size of resulting list. To see that, here is an excerpt from ezyang’s post</p>
<p>For clarity, we rewrite the definition from Haskell 98 to a ++ b = foldr (:) b a, the time complexity is the same.</p>
<pre><code>(as ++ bs) ++ cs
= foldr (:) cs (as ++ bs)
= foldr (:) cs (foldr (:) bs as)
= foldr (:) cs (foldr (:) bs (a:as'))
= foldr (:) cs (a : foldr (:) b as')
= a : foldr (:) cs (foldr (:) bs as')</code></pre>
<p>“This is normal, each string append operation costs you linear time in most programming languages after all.” you said. “Joel Spolsky even make this problem famously known as Schlemiel the Painter’s algorithm.”</p>
<p>But sometimes we DO care about performance. Logger and streaming output of a HTTP server previously mentioned are two of them. We really need efficient list append operation</p>
<p>There are a few reasonable tactics according to Norman Ramsey</p>
<p>Standard list with cons. Difference list (John Hughes list) with constant-time append. Algebraic data type supporting constant-time append: data Alist a = ANil | ASingle a | AAppend (Alist a) (Alist a). List of lists with final concat. It depends on the problem you are working to choose the most appropriate one. Here we focus on the second one, Difference List, because it is the one used in the blaze-builder. It’s originally designed for the streaming output of html. Therefore the append is truly the issue we care about.</p>
<h3 id="difference-list">Difference List</h3>
<p>The difference list is a data strucutre empowers us constant-time append. As the definition given by Haskell Wiki:</p>
<p>It is a function f, which when given a list x, returns the list that f represents, prepended to x. Hard to imagine? Let’s take a look at a concrete example defined in Haskell: the ShowS type: The difference list specifically for List of Char.</p>
<p>Its type in Haskell 98 Report is:</p>
<pre><code>type ShowS = String -&gt; String</code></pre>
<p>Judging from its type, it basically matches the description of a difference list. It is a function accepting a String, and supposedly output a String prepending something to x.</p>
<p>Here is a toy example, using snoc (the inverse of cons) to append Char one by one to the end of difference list.</p>
<pre><code>toString :: ShowS -&gt; String
toString = ($ [])
snoc ∷ ShowS → Char → ShowS
snoc f a = f ∘ (a:)
emptyH ∷ ShowS
emptyH = id
body ∷ String → ShowS → ShowS
body (x:xs) acc = body xs (acc `snoc` x)
body _ acc = acc
run ∷ String → String
run xs = toString (body xs emptyH)
main = putStrLn $ run &quot;1234&quot;</code></pre>
<p>We heavily rely on the function composition of (a:). With composition we can achieve the constant-time append, and stil preserve some properties of a list. To convert a difference list to a normal list of Char, apply the function to an empty list []. It is what toString is doing.</p>
<p>The introduction of a function enables us to evaluate left-associated construction in right-associated fashion.</p>
<pre><code>(as . (bs . cs)) 
= as . bs .cs
= (as . (bs . cs))</code></pre>
<p>With ShowS, we can rewrite the previous example with showString, which is defined as showString s = (s++)`` haskell appendToContent str page = page {pageContent = newContent} where newContent = (pageContent page) . showString str ```</p>
<p>Another excerpt from ezyang’s post proves the work of a difference list. (called Hughes List here)</p>
<pre><code>type Hughes a = [a] -&gt; [a]
listrep :: Hughes a -&gt; [a]
listrep = (\l -&gt; l [])
append :: Hughes a -&gt; Hughes a -&gt; Hughes a
append a b = (\z -&gt; a (b z))
listrep (append (append a b) c)
= (\l -&gt; l []) (append (append a b) c)
= (append (append a b) c) []
= (\z -&gt; (append a b) (c z)) []
= (append a b) (c [])
= (\z -&gt; a (b z)) (c [])
= a (b (c []))</code></pre>
<h3 id="blaze-builder">Blaze-Builder</h3>
<p>Difference list is not limited to list of Char. Elaborating on ShowS is merely for explanation. It can be generalized to list of Chunks, or ByteString for performant output.</p>
<p>Data.Binary.Builder was frontier to use this pattern. The internal working of provided Builder type is essentially a difference list. The purpose of binary package is to encode the Haskell value into binary format and serialize them to external devices, network devices. And blaze-builder, as in Simon’s and Jaspervdj’s introduction (The latter one is a little bit outdated), it is a drop-in replacement for Data.Binary.Builder, with speed and expressiveness enhancement.</p>
<p>A toy example from the documentation:</p>
<pre><code>import Data.Monoid
import qualified Data.ByteString.Lazy as L
import Blaze.ByteString.Builder
import Blaze.ByteString.Builder.Char.Utf8
strings :: [String]
strings = replicate 10000 &quot;Hello World!&quot;
concatenation :: Builder
concatenation = mconcat $ map fromString strings
result :: L.ByteString
result = toLazyByteString concatenation
main = L.putStrLn result</code></pre>
<p>This example serializes 10000 instances of “Hello World” to binary representation, which coincidently to be ASCII encoding of bytes. We use provided fromString to serialize a single String to Builder. And the Builder provides a Monoid interface, which means we have mconcat to efficiently concat them, as we do for the difference list.</p>
<p>After that, we use toLazyByteString to transform it from Builder to ByteString, just like we call toString in the ShowS example.</p>
<p>With ByteString we have putStrLn function to output the binary representation to external devices.</p>
<h3 id="postscript">Postscript</h3>
<p>According to this slide by Simon Meiser. It seems that he is working on bytestring package to incorporate similiar techniques used on blaze-builder. Perhaps after a while the blaze-builder could be replaced by binary. But at this time, a lot of packages are still using blaze-builder. It is still worth it to have a basic understanding of what this library is doing.</p>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
        </main>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-md-3-5">
          <nav class="main-nav">
            
            <span class="newer-posts">
              <a href="../52/">&larr; Newer Posts</a>
            </span>
            
            
            <span class="older-posts" style="float:right">
              <a href="../54/">Older Posts &rarr;</a>
            </span>
            
          </nav>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-1 pure-u-md-3-5">
            <div class="page-number is-center">Page 53 of 59</div>
            <footer class="site-footer">
              <div class="inner is-center">
                <section class="copyright">All contents are copyrighted by Paul Meng, CC BY-NC-SA © 2019</section>
              </div>
            </footer>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>
    </body>
</html>
