<!doctype html>
<html>
    <head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-140890995-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-140890995-1');
  </script>
  <meta charset="utf-8">
  <title>Paul Meng's Blog</title>
  <link rel="canonical" href="https://blog.paulme.ng" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="AhCspkSlkxfv5A28XyOOTijnA59_q-V8rJzKakb4CFA" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta property="og:title" content="Paul Meng's Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://blog.paulme.ng" />

  <link href="https://fonts.googleapis.com/css?family=EB+Garamond|Roboto&display=swap" rel="stylesheet"> 
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP|Noto+Sans+TC&display=optional" rel="stylesheet"> 
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css">
  <link rel="stylesheet" href="../stylesheets/customize-1572179805.css">
  <style>
    html, button, input, select, textarea,
    .pure-g [class *= "pure-u"] {
      font-family: 'Roboto', 'Noto Sans TC', 'Noto Sans JP', sans-serif;
    }

    .post-title {
      font-family: 'EB Garamond', 'Noto Sans TC', 'Noto Sans JP', serif;
    }
  </style>
</head>

    <body>
        <div class="pure-menu pure-menu-horizontal">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><a href="../about" class="pure-menu-link">About</a></li>
                <li class="pure-menu-item"><a href="../archive.html" class="pure-menu-link">Archive</a></li>
                <li class="pure-menu-item"><a href="../rss/feed.xml" class="pure-menu-link">Subscribe</a></li>
            </ul>
        </div>
        <main class="content" role="main">
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2015-05-31-anki.html">Anki 使用して言語を勉強する</a></h1>
    <div class="post-meta"><time datetime="2015-05-31 17:30">2015-05-31 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p>Anki は教材のカードのソフトウエアにとして便利です。何でも言語の学習者へお進めます。カードの重複は科学に基づいたの Spaced Repetition 方法です。答えを見せてあと、簡単、普通、難しの中で貴方の意見選択ます。難しを選ぶんたら、カード現れる再びの可能性は高いです。しかし、ほとんどの人は Anki に使用して、言語の語彙を復習だけです。間違ってはないけど、正しではないです。文にユニットとして覚えた方がいい。ぞれでは、単語の使用の方法がわかります。</p>
<p>Mike Campbellは大量な文トレーニングメソッドの方法論を提出しました。私もこの方法論を支持します。Mike Campbell 設立の会社 Glossika は色んな言語の大量な文の教材を出版した。教材が品質を持ったけれども、文のトピックは私の興味をあわせないです。自分のトランプを作りしたいです、ニュースから、慣用句の本から文を集めたい。それでは、教科書を使うより、モチベーションが強いです。しかし、質良いネイティブスピーカーで録音したのオーディオを捨てたくない。オーディオは文を覚えることが役立ちます。</p>
<p>心配しない、Anki は Awesome TTS のプラグインをインストールできます。インストールあと、文を Google Translate の API で唱えられる。オーデイオはカードと一緒に保存することがでります。もちろん、TTSの声は録音の声ほど自然ではないけれども、空ほど良いです。それでは、自分の大量な面白い文と読み出しのオーディオを作ることが安いなります。</p>
<p>Anki は iOS と Android のバージョンがあります。ダワンロードとインストール後、Ankiweb のアカウントでカードのデータがシンクできる。自分で作るの文を携帯電話に復習できます。</p>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2015-05-30-elasticsearch_dsl.html">elasticsearch_dsl: Domain Specific Language in Python for Elasticsearch</a></h1>
    <div class="post-meta"><time datetime="2015-05-30 17:30">2015-05-30 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p>An emerging trend in recent year for software, including mongodb, elasticsearch and Chef, is to expose an JSON interface to accept complex requests. They give up the traditional SQL query and adopt JSON as the text encoding of abstract syntax tree. Therefore, whenever you are making up a request to these services, you are actually hand coding an abstract syntax tree in JSON. Although it is flexible and easy to extend, it is also error prone and hard to maintain. A common solution for this is to write a Domain Specific Language. And with python’s language design, a naive and natural solution is to use Class to denote AST node and Visitor pattern to code-generate the underlying JSON. And above is the reason I created elasticsearch_dsl</p>
<p>Think that you type the program this way:</p>
<pre><code>nested_agg = ast.NestedAggregation(&quot;name&quot;, &quot;tags&quot;, ast.TermsAggregation(&quot;tags.name&quot;, size=20, order_type=&quot;_count&quot;, order=&quot;desc&quot;, min_doc_count=100))
aggregation = ast.TopLevelAggregation(&quot;tag&quot;, nested_agg)
ast_root = ast.TopLevelQuery(MatchAllQuery(), aggs=[aggregation])

codegen = CodeGeneratorVisitor()
codegen.visit(ast_root)
query_py_obj = codegen.query
and_clauses = []
and_clauses.append(ast.GeoDistanceFilter(&quot;geocode&quot;, user.geocode[&quot;latitude&quot;], user.geocode[&quot;longitude&quot;], 10))

tag_names = []
should_clauses= []
for t, ind in tags:
    should_clauses.append(ast.TermQuery(&quot;tags.name&quot;, t.name.lower()))

nested_queries= ast.BoolQuery(should=should_clauses)
f = ast.NestedQuery(&quot;tags&quot;, nested_queries)

query = ast.FilteredQuery(f, ast.AndFilter(and_clauses))
query_size = 20
query_from = 0
ast_root = ast.TopLevelQuery(query, query_size, query_from, sort={&quot;_score&quot;: {&quot;order&quot;: &quot;desc&quot;}})

codegen = CodeGeneratorVisitor()
codegen.visit(ast_root)
query_py_obj = codegen.query</code></pre>
<p>But not this way</p>
<pre><code>query = {}
query[&quot;tags&quot;] = []
for t, ind in tags:
    query[&quot;tags].append({&quot;tags.name&quot;: t.name.lower()})

query[&quot;size&quot;] = query_size
query[&quot;from&quot;] = query_from
query[&quot;sort&quot;] = {&quot;_score&quot;: {&quot;order&quot;: &quot;desc&quot;}}</code></pre>
<p>which is error prone, and hard to know the intention of each query. There has been a elasticsearch-dsl package on pypi, but one thing I don’t like is the big runtime that comes with it. If anything gets wrong, you have to read almost all of its implementation to know what is error and how to fix it. And this version of elasticsearch_dsl is just a thin wrapper to compile the class into JSON. You could even do it in the command line.</p>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
        </main>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-md-3-5">
          <nav class="main-nav">
            
            <span class="newer-posts">
              <a href="../33/">&larr; Newer Posts</a>
            </span>
            
            
            <span class="older-posts" style="float:right">
              <a href="../35/">Older Posts &rarr;</a>
            </span>
            
          </nav>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-1 pure-u-md-3-5">
            <div class="page-number is-center">Page 34 of 55</div>
            <footer class="site-footer">
              <div class="inner is-center">
                <section class="copyright">All contents are copyrighted by Paul Meng, CC BY-NC-SA © 2019</section>
              </div>
            </footer>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>
    </body>
</html>
