<!doctype html>
<html>
    <head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-140890995-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-140890995-1');
  </script>
  <meta charset="utf-8">
  <title>Paul Meng's Blog</title>
  <link rel="canonical" href="https://blog.paulme.ng" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="AhCspkSlkxfv5A28XyOOTijnA59_q-V8rJzKakb4CFA" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta property="og:title" content="Paul Meng's Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://blog.paulme.ng" />

  <link href="https://fonts.googleapis.com/css?family=EB+Garamond|Roboto&display=swap" rel="stylesheet"> 
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP|Noto+Sans+TC&display=optional" rel="stylesheet"> 
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css">
  <link rel="stylesheet" href="../stylesheets/customize-1622403341.css">
  <style>
    html, button, input, select, textarea,
    .pure-g [class *= "pure-u"] {
      font-family: 'Roboto', 'Noto Sans TC', 'Noto Sans JP', sans-serif;
    }

    .post-title {
      font-family: 'EB Garamond', 'Noto Sans TC', 'Noto Sans JP', serif;
    }
  </style>
</head>

    <body>
        <div class="pure-menu pure-menu-horizontal">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><a href="../about" class="pure-menu-link">About</a></li>
                <li class="pure-menu-item"><a href="../archive.html" class="pure-menu-link">Archive</a></li>
                <li class="pure-menu-item"><a href="../rss/feed.xml" class="pure-menu-link">Subscribe</a></li>
            </ul>
        </div>
        <main class="content" role="main">
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2012-01-17-eta-expansion.html">Floated Out and Eta Expansion</a></h1>
    <div class="post-meta"><time datetime="2012-01-17 17:30">2012-01-17 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p>This write-up was inspired by a question on stackoverflow. The answers explain almost everything, but I still want to dig deeper from GHC implementation. That is to say, I am viewing this problem with core langauge generated with option -ddump-simpl when you compile haskell programs. Let’s start off with an odd number filter.</p>
<pre><code>f1 = ((filter odd [1..]) !!)

f2 x = ((filter odd [1..]) !! x)

main = do
    print $ f1 10000
    print $ f1 10000
    print $ f2 10000
    print $ f2 10000
Without optimization, we get a simple core generated. (I've removed unrelated I/O parts and cleaned it up.)
f2_rbu
  :: forall a_ase. GHC.Real.Integral a_ase =&gt; GHC.Types.Int -&gt; a_ase
[GblId, Arity=2]
f2_rbu =
  \ (@ a_ase)
    ($dIntegral_asf :: GHC.Real.Integral a_ase)
    (eta_B1 :: GHC.Types.Int) -&gt;
    GHC.List.!!
      @ a_ase
      (GHC.List.filter
         @ a_ase
         (GHC.Real.odd @ a_ase $dIntegral_asf)
         (GHC.Enum.enumFrom
            @ a_ase
            (GHC.Real.$p2Integral @ a_ase $dIntegral_asf)
            (GHC.Num.fromInteger
               @ a_ase
               (GHC.Real.$p1Real
                  @ a_ase (GHC.Real.$p1Integral @ a_ase $dIntegral_asf))
               (GHC.Integer.smallInteger 1))))
      eta_B1

f1_rbs :: GHC.Types.Int -&gt; GHC.Integer.Type.Integer
[GblId]
f1_rbs =
  GHC.List.!!
    @ GHC.Integer.Type.Integer
    (GHC.List.filter
       @ GHC.Integer.Type.Integer
       (GHC.Real.odd
          @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger)
       (GHC.Enum.enumFrom
          @ GHC.Integer.Type.Integer
          GHC.Num.$fEnumInteger
          (GHC.Integer.smallInteger 1)))</code></pre>
<p>f1_rbs corresponds to f1 and f2_rbu corresponds to f2 in the source code. You can see that f2_rbu has the form of _B1 -&gt; (!!) filter… eta_B1, but f1_rbs without a surrounding lambda instead (!!) filter…. Clearly, f2_rbu is the eta expansion of f1_rbs. We also know that the inside of a lamda is evaluated each time we call it. Therefore, calling f2_rbu multiple times would results in reconstruction of list. In f1_rbs case, the list is shared among different callings. Next we examine the optimized case with -O2 switched on.</p>
<pre><code>Main.main6 =
  \ (x_aAr :: GHC.Integer.Type.Integer)
    (r_aAs :: [GHC.Integer.Type.Integer]) -&gt;
    case GHC.Integer.remInteger x_aAr GHC.Real.even2 of _ {
      GHC.Integer.Type.S# i_aCs -&gt;
        case i_aCs of _ {
          __DEFAULT -&gt; GHC.Types.: @ GHC.Integer.Type.Integer x_aAr r_aAs;
          0 -&gt; r_aAs
        };
      GHC.Integer.Type.J# s_aCx d_aCy -&gt;
        case {__pkg_ccall_GC integer-gmp integer_cmm_cmpIntegerIntzh GHC.Prim.Int#
                                                        -&gt; GHC.Prim.ByteArray#
                                                        -&gt; GHC.Prim.Int#
                                                        -&gt; GHC.Prim.Int#}_aCw
               s_aCx d_aCy 0
        of _ {
          __DEFAULT -&gt; GHC.Types.: @ GHC.Integer.Type.Integer x_aAr r_aAs;
          0 -&gt; r_aAs
        }
    }

Main.main5 = GHC.Integer.Type.S# 1

Main.main4 =
  GHC.Num.enumDeltaIntegerFB
    @ [GHC.Integer.Type.Integer] Main.main6 Main.main5 Main.main5

Main.main3 = GHC.List.!!_sub @ GHC.Integer.Type.Integer Main.main4 10000

Main.main2 = GHC.Num.$w$cshowsPrec 0 Main.main3 (GHC.Types.[] @ GHC.Types.Char)




Main.main10 =
  \ (x_aAr :: GHC.Integer.Type.Integer)
    (r_aAs :: [GHC.Integer.Type.Integer]) -&gt;
    case GHC.Integer.remInteger x_aAr GHC.Real.even2 of _ {
      GHC.Integer.Type.S# i_aCs -&gt;
        case i_aCs of _ {
          __DEFAULT -&gt; GHC.Types.: @ GHC.Integer.Type.Integer x_aAr r_aAs;
          0 -&gt; r_aAs
        };
      GHC.Integer.Type.J# s_aCx d_aCy -&gt;
        case {__pkg_ccall_GC integer-gmp integer_cmm_cmpIntegerIntzh GHC.Prim.Int#
                                                        -&gt; GHC.Prim.ByteArray#
                                                        -&gt; GHC.Prim.Int#
                                                        -&gt; GHC.Prim.Int#}_aCw
               s_aCx d_aCy 0
        of _ {
          __DEFAULT -&gt; GHC.Types.: @ GHC.Integer.Type.Integer x_aAr r_aAs;
          0 -&gt; r_aAs
        }
    }

Main.main9 =
  GHC.Num.enumDeltaIntegerFB
    @ [GHC.Integer.Type.Integer] Main.main10 Main.main5 Main.main5

Main.main8 = GHC.List.!!_sub @ GHC.Integer.Type.Integer Main.main9 10000

Main.main7 = GHC.Num.$w$cshowsPrec 0 Main.main8 (GHC.Types.[] @ GHC.Types.Char)

Main.main1 =
  \ (s_XYA :: GHC.Prim.State# GHC.Prim.RealWorld) -&gt;
    case GHC.IO.Handle.Text.hPutStr2
           GHC.IO.Handle.FD.stdout Main.main7 GHC.Bool.True s_XYA
    of _ { (# new_s_aXy, _ #) -&gt;
    case GHC.IO.Handle.Text.hPutStr2
           GHC.IO.Handle.FD.stdout Main.main7 GHC.Bool.True new_s_aXy
    of _ { (# new_s1_XYJ, _ #) -&gt;
    case GHC.IO.Handle.Text.hPutStr2
           GHC.IO.Handle.FD.stdout Main.main2 GHC.Bool.True new_s1_XYJ
    of _ { (# new_s2_XYF, _ #) -&gt;
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout Main.main2 GHC.Bool.True new_s2_XYF
    }
    }
    }</code></pre>
<p>The optimized code is a little confusing. The optimized f1 part is definitions from Main.main2 to Main.main6, and optimized f2 part is from Main.main7 to Main.main10. Without too much insight you can observe that the content of Main.main6 and Main.main10 are almost the same. The surrounding lambda of f2 is optimized away. Now go back to the fibonacci program in the question.</p>
<pre><code>fib = let fib' 0 = 0
          fib' 1 = 1
          fib' n = fib (n-1) + fib (n-2)
      in (map fib' [0 ..] !!)

fib2 x = let fib' 0 = 0
             fib' 1 = 1
             fib' n = fib2 (n-1) + fib2 (n-2)
         in map fib' [0 ..] !! x

main = do
    print $ fib 100
    print $ fib2 100</code></pre>
<p>And this is unoptimized version.</p>
<pre><code>(letrec {
  fib_aoC [Occ=LoopBreaker]
    :: GHC.Types.Int -&gt; GHC.Integer.Type.Integer
  [LclId]
  fib_aoC =
    GHC.List.!!
      @ GHC.Integer.Type.Integer
      (GHC.Base.map
         @ GHC.Types.Int
         @ GHC.Integer.Type.Integer
         (\ (ds_ds5 :: GHC.Types.Int) -&gt;
            case ds_ds5 of wild_B1 { GHC.Types.I# ds1_ds6 -&gt;
            case ds1_ds6 of _ {
              __DEFAULT -&gt;
                GHC.Num.+
                  @ GHC.Integer.Type.Integer
                  GHC.Num.$fNumInteger
                  (fib_aoC
                     (GHC.Num.-
                        @ GHC.Types.Int GHC.Num.$fNumInt wild_B1 (GHC.Types.I# 1)))
                  (fib_aoC
                     (GHC.Num.-
                        @ GHC.Types.Int GHC.Num.$fNumInt wild_B1 (GHC.Types.I# 2)));
              0 -&gt; GHC.Integer.smallInteger 0;
              1 -&gt; GHC.Integer.smallInteger 1
            }
            })
         (GHC.Enum.enumFrom
            @ GHC.Types.Int GHC.Enum.$fEnumInt (GHC.Types.I# 0))); } in
fib_aoC (GHC.Types.I# 100))


(letrec {
  fib2_acd [Occ=LoopBreaker]
    :: GHC.Types.Int -&gt; GHC.Integer.Type.Integer
  [LclId, Arity=1]
  fib2_acd =
    \ (x_abA :: GHC.Types.Int) -&gt;
      GHC.List.!!
        @ GHC.Integer.Type.Integer
        (GHC.Base.map
           @ GHC.Types.Int
           @ GHC.Integer.Type.Integer
           (\ (ds_ds0 :: GHC.Types.Int) -&gt;
              case ds_ds0 of wild_B1 { GHC.Types.I# ds1_ds1 -&gt;
              case ds1_ds1 of _ {
                __DEFAULT -&gt;
                  GHC.Num.+
                    @ GHC.Integer.Type.Integer
                    GHC.Num.$fNumInteger
                    (fib2_acd
                       (GHC.Num.-
                          @ GHC.Types.Int GHC.Num.$fNumInt wild_B1 (GHC.Types.I# 1)))
                    (fib2_acd
                       (GHC.Num.-
                          @ GHC.Types.Int GHC.Num.$fNumInt wild_B1 (GHC.Types.I# 2)));
                0 -&gt;
                  GHC.Num.fromInteger
                    @ GHC.Integer.Type.Integer
                    GHC.Num.$fNumInteger
                    (GHC.Integer.smallInteger 0);
                1 -&gt;
                  GHC.Num.fromInteger
                    @ GHC.Integer.Type.Integer
                    GHC.Num.$fNumInteger
                    (GHC.Integer.smallInteger 1)
              }
              })
           (GHC.Enum.enumFrom
              @ GHC.Types.Int GHC.Enum.$fEnumInt (GHC.Types.I# 0)))
        x_abA; } in
fib2_acd (GHC.Types.I# 100))</code></pre>
<p>You can see the pattern that one has lambda outside and another doesn’t. fib_aoC is (!!) (map (_ds5 -&gt; …) enumFrom…) and fib2_acd is _abA -&gt; (!!) (map (_ds0 -&gt; …) enumFrom…) x_abA). As for -O2 version. We can view the code in two groups:</p>
<ul>
<li>Main.main7, Main.main_sgo, go_rUQ, Main.amin6, Main.main5, which corresponds to fib.</li>
<li>sgo_rUS, go1_rUW, a_rUV, Main.wfib2, Main.main3, which corresponds to fib2</li>
</ul>
<pre><code>Main.main7 = GHC.Integer.Type.S# 0

Main.main_$sgo = GHC.Types.: @ GHC.Integer.Type.Integer Main.main7 Main.main6

go_rUQ =
  \ (x_avk :: GHC.Prim.Int#) -&gt;
    GHC.Types.:
      @ GHC.Integer.Type.Integer
      (case x_avk of ds_Xsb {
         __DEFAULT -&gt;
           let {
             n0_asK [Dmd=Just L] :: GHC.Prim.Int#
             n0_asK = GHC.Prim.-# ds_Xsb 1 } in
           case GHC.Prim.&lt;# n0_asK 0 of _ {
             GHC.Bool.False -&gt;
               let {
                 n1_XtE [Dmd=Just L] :: GHC.Prim.Int#
                 n1_XtE = GHC.Prim.-# ds_Xsb 2 } in
               case GHC.Prim.&lt;# n1_XtE 0 of _ {
                 GHC.Bool.False -&gt;
                   GHC.Integer.plusInteger
                     (GHC.List.!!_sub @ GHC.Integer.Type.Integer Main.main_$sgo n0_asK)
                     (GHC.List.!!_sub @ GHC.Integer.Type.Integer Main.main_$sgo n1_XtE);
                 GHC.Bool.True -&gt;
                   GHC.List.!!1
                   `cast` (CoUnsafe (forall a_asR. a_asR) GHC.Integer.Type.Integer
                           :: (forall a_asR. a_asR) ~ GHC.Integer.Type.Integer)
               };
             GHC.Bool.True -&gt;
               GHC.List.!!1
               `cast` (CoUnsafe (forall a_asR. a_asR) GHC.Integer.Type.Integer
                       :: (forall a_asR. a_asR) ~ GHC.Integer.Type.Integer)
           };
         0 -&gt; Main.main7;
         1 -&gt; lvl_rUL
       })
      (case x_avk of wild_B1 {
         __DEFAULT -&gt; go_rUQ (GHC.Prim.+# wild_B1 1);
         2147483647 -&gt; GHC.Types.[] @ GHC.Integer.Type.Integer
       })

Main.main6 = go_rUQ 1

Main.main5 = GHC.List.!!_sub @ GHC.Integer.Type.Integer Main.main_$sgo 100

$sgo_rUS = GHC.Types.: @ GHC.Integer.Type.Integer Main.main7 a_rUV

go1_rUW =
  \ (x_avk :: GHC.Prim.Int#) -&gt;
    GHC.Types.:
      @ GHC.Integer.Type.Integer
      (case x_avk of ds_Xs9 {
         __DEFAULT -&gt;
           GHC.Integer.plusInteger
             (Main.$wfib2 (GHC.Prim.-# ds_Xs9 1))
             (Main.$wfib2 (GHC.Prim.-# ds_Xs9 2));
         0 -&gt; Main.main7;
         1 -&gt; lvl_rUL
       })
      (case x_avk of wild_B1 {
         __DEFAULT -&gt; go1_rUW (GHC.Prim.+# wild_B1 1);
         2147483647 -&gt; GHC.Types.[] @ GHC.Integer.Type.Integer
       })

a_rUV = go1_rUW 1

Main.$wfib2 =
  \ (ww_sU0 :: GHC.Prim.Int#) -&gt;
    case GHC.Prim.&lt;# ww_sU0 0 of _ {
      GHC.Bool.False -&gt;
        GHC.List.!!_sub @ GHC.Integer.Type.Integer $sgo_rUS ww_sU0;
      GHC.Bool.True -&gt; GHC.List.!!1 @ GHC.Integer.Type.Integer
    }
end Rec }

Main.main3 = Main.$wfib2 100

Main.main2 = GHC.Num.$w$cshowsPrec 0 Main.main3 (GHC.Types.[] @ GHC.Types.Char)</code></pre>
<p>Both definitions are dissected into the form sgo (indirectly) calls go_XXX, and inside go_XXX it calls back sgo. The lambda is optimized away, hence the performance is improved. The experiment setting is GHC 7.0.2 on ArchLinux, 32 bits. Here I merely try to view the problem from the core language, and I don’t intend to try the affect of type hint as mentioned in the original thread.</p>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2011-12-24-data-typeable.html">What are Data.Typeable and Data.Dynamic in Haskell</a></h1>
    <div class="post-meta"><time datetime="2011-12-24 17:30">2011-12-24 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p>While you are tracing serious haskell package, you probably would bump into something like this and wonder what it is.</p>
<pre><code>foo :: Typeable a =&gt; a -&gt; Maybe b</code></pre>
<p>Then you look it up on hackage and see the following confusing paragraph.</p>
<p>The Typeable class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation. To this end, an unsafe cast is guarded by a test for type (representation) equivalence. The module Data.Dynamic uses Typeable for an implementation of dynamics. The module Data.Data uses Typeable and type-safe cast (but not dynamics) to support the “Scrap your boilerplate” style of generic programming. You could also google to don’s writeup on stackoverflow giving the references. Don gave four of the references but I found two of them most related, they are:</p>
<p>Lammel, Ralf and Jones, Simon Peyton, “Scrap your boilerplate: a practical design pattern for generic programming, TLDI ’03: Proceedings of the 2003 ACM SIGPLAN International Workshop on Types in Languages Design and Implementation, 2003 Martín Abadi, Luca Cardelli, Benjamin Pierce and Gordon Plotkin, “Dynamic Typing in a Statically Typed Language”, ACM Transactions on Programming Languages and Systems (TOPLAS), 1991. And here is my understanding after reading these two and doing a little experiment with GHC.</p>
<p>Typeable literally means able to ask its type (tag). It’s a typeclass defined in Data.Typeable with a function typeOf :: a -&gt; TypeRep in it. Do you feel familiar with keyword typeOf? It reminds you either typeof in javascript, typeid in C++, or instanceof in java. Typeable mechanism is kind of like Reflection, using typeOf (1::Int) can tell you the type representation (or you can just think of it type) of (1::Int) There are numerous types in standard library defined as instances of Typeable, so I do a little experiment by printing their type represection.</p>
<pre><code>import Data.Int
import Data.Word
import Data.Ord
import Data.Typeable
import Control.Monad.ST
import Control.Exception
import Foreign.C.Types

main = do
    putStrLn $ show $ typeOf (True::Bool)
    putStrLn $ show $ typeOf ('c'::Char)
    putStrLn $ show $ typeOf (1.0::Double)
    putStrLn $ show $ typeOf (1.0::Float)
    putStrLn $ show $ typeOf (1::Int)
    putStrLn $ show $ typeOf (1::Int8)
    putStrLn $ show $ typeOf (1::Int16)
    putStrLn $ show $ typeOf (1::Int32)
    putStrLn $ show $ typeOf (1::Int64)
    putStrLn $ show $ typeOf (1::Integer)
    putStrLn $ show $ typeOf (undefined::Ordering)
    putStrLn $ show $ typeOf (undefined::RealWorld)
    putStrLn $ show $ typeOf (undefined::Word)
    putStrLn $ show $ typeOf (undefined::Word8)
    putStrLn $ show $ typeOf (undefined::Word16)
    putStrLn $ show $ typeOf (undefined::Word32)
    putStrLn $ show $ typeOf (undefined::Word64)
    putStrLn $ show $ typeOf (undefined::())
    putStrLn $ show $ typeOf (undefined::TyCon)
    putStrLn $ show $ typeOf (undefined::TypeRep)
    putStrLn $ show $ typeOf (undefined::ArithException)
    putStrLn $ show $ typeOf (undefined::ErrorCall)
    putStrLn $ show $ typeOf (undefined::SomeException)
    putStrLn $ show $ typeOf (undefined::IOException)
    putStrLn $ show $ typeOf (undefined::CUIntMax)
    putStrLn $ show $ typeOf (undefined::CIntMax)
    putStrLn $ show $ typeOf (undefined::CUIntPtr)
    putStrLn $ show $ typeOf (undefined::CIntPtr)
Bool
Char
Double
Float
Int
Int8
Int16
Int32
Int64
Integer
Ordering
RealWorld
Word
Word8
Word16
Word32
Word64
()
TyCon
TypeRep
GHC.Exception.ArithException
GHC.Exception.ErrorCall
GHC.Exception.SomeException
GHC.IO.Exception.IOException
CUIntMax
CIntMax
CUIntPtr
CIntPtr</code></pre>
<p>You can see that from ArithException, the output becomes GHC.Exception.ArithException, and ErrorCall becomes GHC.Exception.ErrorCall, not just boring identity from Int to Int, Char to Char. typeOf not just show it’s type but some type representation.</p>
<p>It’s first official definition was shown in “scrap your boilerplate.” Here is the working excerpt of a reference implementation from the paper.</p>
<pre><code>import Unsafe.Coerce

class Typeable a where
    typeOf :: a -&gt; TypeRep

data TypeRep = TR String [TypeRep] deriving (Eq, Show)

instance Typeable Int where
    typeOf x = TR &quot;Prelude.Int&quot; []

instance Typeable Bool where
    typeOf x = TR &quot;Prelude.Bool&quot; []

instance Typeable a =&gt; Typeable [a] where
    typeOf x = TR &quot;Prelude.List&quot; [typeOf (get x)]
        where
            get :: [a] -&gt; a
            get = undefined

instance (Typeable a, Typeable b) =&gt; Typeable (a-&gt;b) where
    typeOf f = TR &quot;Prelude.-&gt;&quot; [typeOf (getArg f), typeOf (getRes f)]
        where getArg :: (a-&gt;b) -&gt; a
              getArg = undefined
              getRes :: (a-&gt;b) -&gt; b
              getRes = undefined

cast :: (Typeable a, Typeable b) =&gt; a -&gt; Maybe b
cast x = r
    where
        r = if typeOf x == typeOf (get r)
                then Just (unsafeCoerce x)
                else Nothing
        get :: Maybe a -&gt; a
        get x = undefined

main = do
    putStrLn $ show $ typeOf (1::Int)</code></pre>
<p>Although the intention to define Typeable typeclass in “scrap your boilerplate” is for generic programming, it is found useful in defining dynamic type, and that is what Data.Dynamic used for. As the previous quote says:</p>
<p>The module Data.Dynamic uses Typeable for an implementation of dynamics. Then why do we need dynamic type in a static type language? An excerpt from “Dynamic Typing in a Statically Typed Language” tell us. &gt; There is often the need to deal with data whose type cannot be &gt; determined at compile time. For example, full static typechecking &gt; of programs that exchange data with other programs or access persistent &gt; data is in general not possible. A certain amount of dynamic checking must &gt; be performed in order to preserve type safety.</p>
<p>A solution to this is to define a static Dynamic type, which internally could be considered as a tuple of (binary representation, type tag). When the program communicates with external resources, all of the type is converted to Dynamic. You could achieve runtime type safety by inspecting its type tag (with typeOf function)</p>
<p>An example of this is Heterogeneous List</p>
<pre><code>import Data.Dynamic
import Data.Maybe

hlist :: [Dynamic]
hlist = [toDyn &quot;string&quot;,
         toDyn (7::Int),
         toDyn (pi :: Double),
         toDyn 'x',
         toDyn ((), Just &quot;foo&quot;)]

dyn :: Dynamic
dyn = hlist !! 1

v :: Int
v = case fromDynamic dyn of
         Nothing -&gt; error &quot;Type mismatch&quot;
         Just x -&gt; x

main = do putStrLn $ show v</code></pre>
<p>Postscript: Haskell 98 limits the typeclass that is auto derivable. To switch on auto derivation of Typeable, please check auto deriving</p>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
        </main>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-md-3-5">
          <nav class="main-nav">
            
            <span class="newer-posts">
              <a href="../55/">&larr; Newer Posts</a>
            </span>
            
            
            <span class="older-posts" style="float:right">
              <a href="../57/">Older Posts &rarr;</a>
            </span>
            
          </nav>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-1 pure-u-md-3-5">
            <div class="page-number is-center">Page 56 of 59</div>
            <footer class="site-footer">
              <div class="inner is-center">
                <section class="copyright">All contents are copyrighted by Paul Meng, CC BY-NC-SA © 2019</section>
              </div>
            </footer>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>
    </body>
</html>
