<!doctype html>
<html>
    <head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-140890995-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-140890995-1');
  </script>
  <meta charset="utf-8">
  <title>Paul Meng's Blog</title>
  <link rel="canonical" href="https://blog.paulme.ng" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="AhCspkSlkxfv5A28XyOOTijnA59_q-V8rJzKakb4CFA" />

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <meta property="og:title" content="Paul Meng's Blog" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://blog.paulme.ng" />

  <link href="https://fonts.googleapis.com/css?family=EB+Garamond|Roboto&display=swap" rel="stylesheet"> 
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP|Noto+Sans+TC&display=optional" rel="stylesheet"> 
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css">
  <link rel="stylesheet" href="../stylesheets/customize-1622403341.css">
  <style>
    html, button, input, select, textarea,
    .pure-g [class *= "pure-u"] {
      font-family: 'Roboto', 'Noto Sans TC', 'Noto Sans JP', sans-serif;
    }

    .post-title {
      font-family: 'EB Garamond', 'Noto Sans TC', 'Noto Sans JP', serif;
    }
  </style>
</head>

    <body>
        <div class="pure-menu pure-menu-horizontal">
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><a href="../about" class="pure-menu-link">About</a></li>
                <li class="pure-menu-item"><a href="../archive.html" class="pure-menu-link">Archive</a></li>
                <li class="pure-menu-item"><a href="../rss/feed.xml" class="pure-menu-link">Subscribe</a></li>
            </ul>
        </div>
        <main class="content" role="main">
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2012-06-25-haskell-async.html">Hakell Library Survey: Async</a></h1>
    <div class="post-meta"><time datetime="2012-06-25 17:30">2012-06-25 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p>My friends and I have been working on a haskell binding to libpulse, in the hope to provide a much thorough API than pulse-simple, which only bound the limited simple API but not the async API Due to the innate asynchronous architecture of libpulse and the emulated synchronous interface we want to provide to the users, we have to deal with a lot of dirty jobs with respect to asynchronous behaviours. We did some surveys and here is a little memo I decide to write it down.</p>
<p>Suppose you want to concurrently download the content of two links, take whatever return first and drop the other one. How would you implement this in Haskell? One way is to implement a select in haskell, the select is named after the select from POSIX</p>
<pre><code>import Control.Concurrent
import Control.Concurrent.STM
import Network.Curl.Download
import qualified Data.ByteString.Char8 as B

downloadThread :: String -&gt; TMVar B.ByteString -&gt; IO ()
downloadThread url tmvar = do
    page &lt;- openURI url
    case page of 
        Left s -&gt; return ()
        Right c -&gt; atomically $ putTMVar tmvar c

select :: [TMVar a] -&gt; STM a
select = foldr1 orElse . map takeTMVar

main = do
    tmvar1 &lt;- atomically $ newEmptyTMVar
    tmvar2 &lt;- atomically $ newEmptyTMVar
    forkIO $ downloadThread &quot;http://www.google.com&quot; tmvar1
    forkIO $ downloadThread &quot;http://www.yahoo.com&quot; tmvar2 
    page &lt;- atomically $ select [tmvar1, tmvar2]
    B.putStrLn page</code></pre>
<p>With the help of TMVar, we can wait for the completion of the forked jobs, hence we can emulate a synchronous behaviour building on the top of this.</p>
<p>When you come up with an idea, a high probability is it have been already implemented by somebody else and been uploaded to hackage. Here is an interfance provided by async, which is implemented by Simon Marlow</p>
<pre><code>import Network.Curl.Download
import Control.Concurrent.Async
import qualified Data.ByteString.Char8 as B

downloadThread :: String -&gt; IO B.ByteString
downloadThread url = do
    page &lt;- openURI url
    case page of 
        Left s -&gt; error s
        Right c -&gt; return c

main = do
    withAsync (downloadThread &quot;http://www.google.com&quot;) $ \a1 -&gt; do
    withAsync (downloadThread &quot;http://www.yahoo.com&quot;) $ \a2 -&gt; do
    res &lt;- waitEither a1 a2
    case res of
        Left page1 -&gt; B.putStrLn page1
        Right page2 -&gt; B.putStrLn page2</code></pre>
<p>The package adds a thin layer over the concurrency operations provided by Contrlo.Concurrent. It defines type Async to provide some safety. Basically it works the same way underlying, using STM for synchronization and using fork# instead of forkIO for optimization.</p>
<p>Some disadvantages of this library is that it is tightly-coupled with IO, if you want to define MonadIO, it is not currently supported. It also uses lightweight thread, so in the case of libpulse, which uses OS threads on its own. Interacting with it through foreign function interface would be a problem.</p>
<p>If you are interested in our project, you can fork us on pulse. It has not completed yet, but we devoted a lot of time working on it. Hope soon it would be in beta stage.</p>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
                <article class="post">
                    <div class="pure-g">
  <div class="pure-u-md-1-5"></div>
  <div class="pure-u-1 pure-u-md-3-5">
    <h1 class="post-title is-center"><a href="../posts/2012-06-08-race-against-machine.html">Race Against The Machine 讀後感</a></h1>
    <div class="post-meta"><time datetime="2012-06-08 17:30">2012-06-08 17:30</time> </span>
    <div class="slot-content">
      <article>
        <p><img src="../images/legacy/0*USBbtN5FC1-hK4fE.jpg" /></p>
<p>Race Against The Machine嚴格說來這並不是一本書， 而是幾個短章節組成的專文，類似一般雜誌中的專題探討之類。 我是看到Tim O’Reilly大叔在Google+上看到他簡短的推薦， 加上本身就有類似的想法決定看看是否有先進將我零碎的想法已經研究得透徹。</p>
<p>這篇專文主要是從一些經濟上的觀察開始講起， 包括了自金融海嘯以來，以往有效的貨幣手段似乎不再效果顯著， 儘管美國利率已經降到低到不行，資金放寬但消費就是起不來，失業率也居高不下。 同時間，美國各個教育水平的收入也在不停分化， 過去美國十年的增長，大部分增長的財富都集中在社會前百分之二十的人手上。 而且符合power law，越往前頭的百分比累積財富的速度越多。 作者認為撇除掉全球化，法規等因素讓原本在美國的低階工作流往海外等因素， 大家太輕忽了科技的影響力。 在這段時間，科技爆發性地成長，摩爾定律讓計算資源源源不絕地噴發出來。 導致許多工作都自動化，同樣的工作不再需要人。 他在第三章開頭就引用了凱因思的話：</p>
<p>We are being afflicted with a new disease of which some readers may not yet have heard the name, but of which they will hear a great deal in the years to come - namely, technological unemployment. This means unemployment due to our discovery of means of economising the use of labour outrunning the pace at which we can find new use for labour. - John Maynard Keynes, 1930</p>
<p>套到如今似乎也是如此適用。</p>
<p>機器不斷地在侵蝕原本我們認為是人專屬的領域，重點是這個勢頭來得如此之猛，讓我們的教育，政治組織架構來不及反應。 書中舉了幾個例子，包括Google的自動駕駛，IBM參加Joepardy超級電腦。 我們原本認為複雜的Pattern Recognition像是駕駛是非常難的，但現在的運算資源跟資料如此豐富讓我們可以達成這艱難的任務。 除了這些，我自己也看過好幾個例子。 像是我在Discovery上看過超級工廠系列。 有一集提到可口可樂操作整個裝瓶工場的人員不過是幾個人， 他們操作複雜的儀表控制整個工廠，包括精密的標籤機， 可以用雷射精準貼瓶到幾mm，如果超過標準就要放棄。 或是像海尼根在荷蘭的工廠，裡面從裝好瓶的機器搬運到貨車上整個作業全部由機器人處理， 可以精準的一箱箱搬到卡車上，卡車在根據排得精準的行程開往港口。 甚至我也在演算法交易的書上看過， 說最近幾年由於對於市場微結構的理解，還有電腦的進步，演算法的進步， 現在已經不像以前需要僱用那麼多交易員來處理每天的交易了。 像是常見的工作要把大單拆小慢慢丟到市場裡， 或是隨時監控不同交易所的執行條件作Routing執行等工作電腦作的已經非常好。 只要沒有碰到市場大風大浪，基本上是不太需要人參與的。 這樣就可以把交易手續費降到非常便宜，而開放API讓外面的人直接透過API交易也是這樣來的。 只要在碰到市場波動的時候再由明星交易員來手動開船就好。</p>
<p>再舉一個算是個人偏見的例子， 我認為現今的主流程式語言都太弱了，如果對於程式語言有一點點深入研究，會發現學界已經有很多厲害的東西但還沒普及。 如果能夠有一個足夠強的static type的語言讓大家使用，我認為可以減少非常多除錯的時間，讓整體生產力提昇。 現今的所標榜的各種Testing導向的開發，根本都是搶Compiler的工作來作，而且還作得沒有機器好，產生出一堆bug。 如果有一天我們能夠有一個很好的程式語言，夠強的Compiler，一間軟體公司根本可以減少許多測試，開發的人力。 甚至一個Compiler根本可以取代掉很多不合格的Programmers。 機器不需要作到完美，只需要作到足夠好就可以取代掉人類。</p>
<p>雖然我認為書中舉的一些資料是有爭議的， 至少不是能直接跳到作者宣稱的結論。 但我自己也相信在這個世代機器絕對會搶人的工作， 直到長期人類可以開創出另外的產業讓大家都能有工作。 有時候在想像是i-robot，real steel等電影中的未來世界，人們到底在作些什麼樣的工作呢？ 假如有一天一個智慧型機器人便宜到唾手可得，就像現在的PC一樣，這樣的世界還有什麼樣的工作需要人作？</p>
<p>科技的成長速度在今後十年或許只會越來越快， 所謂的雲端運算我個人偏見認為或許稱為普及運算是更恰當， 今後十年運算資源會不斷地侵入生活中的每一個地方， 也許Google的無人駕駛車會讓很多物流系統自動化，海尼根的貨車現在還是人在開也變成無人駕駛。 Amazon的遞送系統不再有送貨員，無人駕駛車會自動開到你家， 並且在快到你家的時候自動用語音系統打一通電話請你出來收貨。 隨便你想到的一個東西都可能嵌有運算資源並配上用不盡的IPv6位址。 你吃完Pizza後可能連垃圾桶都智慧化，聯網來計算怎樣可以最有效的回收利用垃圾。</p>
<p>這樣的未來，也會加速所謂的資訊落差， 能夠掌握知識與資訊的人會佔盡優勢。 資本與人力的界線或許也會越來越模糊（智慧型機器人的用途究竟要算人力還是資本呢？） Iron Man 2裡面Whiplash在製造系統的時候曾說過一句話， 『人不可靠，人會犯錯，應該用遙控的』或許在未來這句話會越來越適用於這場人與機器的賽跑中。</p>

      </article>
    </div>
  </div>
  <div class="pure-u-md-1-5"></div>
</div>

                </article>
            
        </main>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-md-3-5">
          <nav class="main-nav">
            
            <span class="newer-posts">
              <a href="../50/">&larr; Newer Posts</a>
            </span>
            
            
            <span class="older-posts" style="float:right">
              <a href="../52/">Older Posts &rarr;</a>
            </span>
            
          </nav>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>

        <div class="pure-g">
          <div class="pure-u-md-1-5"></div>
          <div class="pure-u-1 pure-u-md-3-5">
            <div class="page-number is-center">Page 51 of 59</div>
            <footer class="site-footer">
              <div class="inner is-center">
                <section class="copyright">All contents are copyrighted by Paul Meng, CC BY-NC-SA © 2019</section>
              </div>
            </footer>
          </div>
          <div class="pure-u-md-1-5"></div>
        </div>
    </body>
</html>
